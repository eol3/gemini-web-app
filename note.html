<!DOCTYPE html>
<html lang="zh-TW">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æœ¬åœ°æª”æ¡ˆå¼è¨˜äº‹æœ¬ (è³‡æ–™å¤¾ç®¡ç†ç‰ˆ)</title>
    <!-- è¼‰å…¥ Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- è¼‰å…¥ Inter å­—é«” -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <!-- è¼‰å…¥ JSZip å‡½å¼åº« -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f7f9fb;
        }

        .editable-field {
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        .image-preview-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
            gap: 0.5rem;
        }

        .image-thumbnail {
            position: relative;
            aspect-ratio: 1;
            overflow: hidden;
            border-radius: 0.5rem;
            border: 1px solid #e2e8f0;
        }

        .image-thumbnail img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .remove-img-btn {
            position: absolute;
            top: 2px;
            right: 2px;
            background: rgba(0, 0, 0, 0.5);
            color: white;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            cursor: pointer;
            transition: background 0.2s;
        }

        .remove-img-btn:hover {
            background: rgba(220, 38, 38, 0.9);
        }

        .custom-scrollbar::-webkit-scrollbar {
            height: 8px;
        }

        .custom-scrollbar::-webkit-scrollbar-track {
            background: #f1f5f9;
            border-radius: 4px;
        }

        .custom-scrollbar::-webkit-scrollbar-thumb {
            background: #cbd5e1;
            border-radius: 4px;
        }

        .custom-scrollbar::-webkit-scrollbar-thumb:hover {
            background: #94a3b8;
        }

        .custom-scrollbar {
            scrollbar-width: thin;
            scrollbar-color: #cbd5e1 #f1f5f9;
        }

        .lightbox-img {
            max-width: 90vw;
            max-height: 90vh;
            object-fit: contain;
            transition: transform 0.3s ease;
        }

        /* æ‰‹å‹•å®šç¾© tag-badge æ¨£å¼ */
        .tag-badge {
            background-color: #dbeafe;
            /* bg-blue-100 */
            color: #1e40af;
            /* text-blue-800 */
            font-size: 0.75rem;
            /* text-xs */
            font-weight: 500;
            /* font-medium */
            margin-right: 0.5rem;
            /* me-2 */
            padding: 0.125rem 0.625rem;
            /* py-0.5 px-2.5 */
            border-radius: 0.25rem;
            /* rounded */
            display: inline-block;
        }

        /* å·²ç§»é™¤å°è‡´è¡çªçš„ .hidden { display: none !important; } */
    </style>
</head>

<body class="min-h-screen">
    <div class="max-w-4xl mx-auto p-4 sm:p-6 lg:p-8">
        <header class="text-center mb-6">
            <h1 class="text-4xl font-extrabold text-indigo-700">æœ¬åœ°æª”æ¡ˆå¼è¨˜äº‹æœ¬</h1>
            <p id="storage-type-info"
                class="text-sm text-gray-500 mt-2 p-2 bg-white inline-block rounded-full shadow-inner">è³‡æ–™å„²å­˜åœ¨ç€è¦½å™¨
                IndexedDB ä¸­ã€‚</p>
            <p id="note-count-status"
                class="text-sm text-gray-500 mt-1 p-1 bg-white inline-block rounded-full shadow-inner">æ­£åœ¨æª¢æŸ¥å„²å­˜ç‹€æ…‹...</p>
        </header>

        <div class="bg-white p-4 rounded-xl shadow-lg mb-6 border border-gray-100">
            <div class="flex flex-wrap items-center justify-between sm:justify-start gap-2">
                <!-- æ‰‹æ©Ÿç‰ˆæ§åˆ¶å€ -->
                <div class="flex items-center gap-2 w-full sm:w-auto justify-between sm:justify-start">
                    <div class="flex gap-2">
                        <!-- æ¼¢å ¡æŒ‰éˆ• -->
                        <button id="mobile-menu-btn"
                            class="sm:hidden p-2 text-gray-600 hover:bg-gray-100 rounded-lg focus:outline-none">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24"
                                stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                    d="M4 6h16M4 12h16M4 18h16" />
                            </svg>
                        </button>
                        <button id="toggle-form-btn"
                            class="w-full sm:w-auto py-2 px-4 bg-indigo-600 text-white font-semibold rounded-lg shadow-md hover:bg-indigo-700 transition duration-150 transform hover:scale-[1.01] flex items-center justify-center space-x-2">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24"
                                stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                    d="M12 4v16m8-8H4" />
                            </svg><span>æ–°å¢è¨˜äº‹</span>
                        </button>
                    </div>
                </div>

                <!-- é¸å–®å€ -->
                <div id="toolbar-menu"
                    class="hidden sm:flex flex-col sm:flex-row w-full sm:w-auto gap-6 items-stretch sm:items-center mt-6 sm:mt-0">
                    <div class="relative w-full sm:w-auto">
                        <select id="storage-selector"
                            class="w-full py-2 pl-3 pr-8 bg-white border border-gray-300 text-gray-700 font-semibold rounded-lg shadow-sm focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 cursor-pointer">
                            <option value="idb">å„²å­˜ä½ç½®ï¼šç€è¦½å™¨ (IndexedDB)</option>
                            <option value="fs_manage">âš™ï¸ ç®¡ç†å„²å­˜è³‡æ–™å¤¾...</option>
                        </select>
                    </div>

                    <button id="reconnect-btn"
                        class="hidden w-full sm:w-auto py-2 px-4 bg-blue-500 text-white font-semibold rounded-lg shadow-md hover:bg-blue-600 transition duration-150 transform hover:scale-[1.01] flex items-center justify-center space-x-2">
                        <!-- SVG icon set in JS -->
                    </button>

                    <button id="set-folder-btn"
                        class="hidden w-full sm:w-auto py-2 px-4 bg-blue-600 text-white font-semibold rounded-lg shadow-md hover:bg-blue-700 transition duration-150 transform hover:scale-[1.01] flex items-center justify-center space-x-2">
                        <span>è¨­å®šå„²å­˜è³‡æ–™å¤¾</span>
                    </button>

                    <button id="export-btn"
                        class="w-full sm:w-auto py-2 px-4 bg-green-500 text-white font-semibold rounded-lg shadow-md hover:bg-green-600 transition duration-150 transform hover:scale-[1.01] flex items-center justify-center space-x-2">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                            <path fill-rule="evenodd"
                                d="M3 17a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zm3.293-7.707a1 1 0 011.414 0L9 11.586V3a1 1 0 112 0v8.586l1.293-1.293a1 1 0 111.414 1.414l-3 3a1 1 0 01-1.414 0l-3-3a1 1 0 010-1.414z"
                                clip-rule="evenodd" />
                        </svg><span>åŒ¯å‡º (.zip)</span>
                    </button>
                    <button id="import-btn"
                        class="w-full sm:w-auto py-2 px-4 bg-yellow-500 text-white font-semibold rounded-lg shadow-md hover:bg-yellow-600 transition duration-150 transform hover:scale-[1.01] flex items-center justify-center space-x-2">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                            <path fill-rule="evenodd"
                                d="M3 17a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM6.293 8.707a1 1 0 010-1.414l3-3a1 1 0 011.414 0l3 3a1 1 0 01-1.414 1.414L11 6.414V14a1 1 0 11-2 0V6.414L7.707 8.707a1 1 0 01-1.414 0z"
                                clip-rule="evenodd" />
                        </svg><span>åŒ¯å…¥ (.zip)</span>
                    </button>
                </div>
            </div>
        </div>

        <div id="note-form-container"
            class="relative bg-white p-6 rounded-2xl shadow-xl mb-8 border border-gray-100 hidden">
            <button id="close-form-btn"
                class="absolute top-3 right-3 p-2 text-gray-400 hover:text-gray-600 rounded-full transition duration-150"
                aria-label="é—œé–‰è¡¨å–®"><svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none"
                    viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
                </svg></button>
            <h2 class="text-2xl font-semibold text-gray-700 mb-4 border-b pb-2">æ–°å¢ç­†è¨˜å…§å®¹</h2>
            <form id="note-form">
                <input type="text" id="note-title" placeholder="è«‹è¼¸å…¥æ¨™é¡Œ" required
                    class="w-full p-3 mb-4 border border-gray-300 rounded-lg focus:ring-indigo-500 focus:border-indigo-500 transition duration-150 text-gray-800">
                <textarea id="note-content" placeholder="è«‹è¼¸å…¥ç­†è¨˜å…§å®¹..." rows="4" required
                    class="w-full p-3 mb-4 border border-gray-300 rounded-lg focus:ring-indigo-500 focus:border-indigo-500 transition duration-150 text-gray-800 resize-y"></textarea>

                <label class="block mb-2 text-sm font-medium text-gray-600">é™„åŠ åœ–ç‰‡ (å¯å¤šé¸)</label>
                <input type="file" id="image-input" accept="image/*"
                    class="w-full p-2 mb-2 border border-gray-300 rounded-lg focus:ring-indigo-500 focus:border-indigo-500 text-gray-800 text-sm">
                <div id="image-preview" class="mb-3"></div>
                <button type="button" id="remove-image-btn"
                    class="hidden text-red-500 hover:text-red-700 text-sm font-semibold p-1 rounded-md transition duration-150 mb-4">ç§»é™¤åœ–ç‰‡</button>

                <label class="block mb-2 text-sm font-medium text-gray-600">é™„åŠ å½±ç‰‡ (å¯å¤šé¸)</label>
                <input type="file" id="video-input" accept="video/*"
                    class="w-full p-2 mb-2 border border-gray-300 rounded-lg focus:ring-indigo-500 focus:border-indigo-500 text-gray-800 text-sm">
                <div id="video-preview" class="mb-3"></div>

                <!-- æ¨™ç±¤è¼¸å…¥æ¬„ä½ç§»åˆ°é€™è£¡ -->
                <label class="block mb-2 text-sm font-medium text-gray-600">æ¨™ç±¤</label>
                <input type="text" id="note-tags" placeholder="è¼¸å…¥æ¨™ç±¤ (ä½¿ç”¨é€—è™Ÿåˆ†éš”ï¼Œä¾‹å¦‚: å·¥ä½œ, é‡è¦)"
                    class="w-full p-3 mb-4 border border-gray-300 rounded-lg focus:ring-indigo-500 focus:border-indigo-500 transition duration-150 text-gray-800 text-sm">

                <button type="submit"
                    class="w-full py-3 bg-indigo-600 text-white font-bold rounded-lg shadow-md hover:bg-indigo-700 transition duration-200 transform hover:scale-[1.01] active:scale-[0.99] flex items-center justify-center space-x-2">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24"
                        stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                            d="M12 9v3m0 0v3m0-3h3m-3 0H9m12 0a9 9 0 11-18 0 9 9 0 0118 0z" />
                    </svg><span>å„²å­˜è¨˜äº‹</span>
                </button>
            </form>
        </div>

        <div class="mb-8">
            <!-- åˆ—è¡¨æ¨™é¡Œå€ -->
            <div class="flex justify-between items-center mb-4 border-b pb-2">
                <h2 class="text-2xl font-semibold text-gray-700">è¨˜äº‹åˆ—è¡¨</h2>
                <div class="flex items-center space-x-2">
                    <div class="relative">
                        <select id="tag-filter"
                            class="p-2 border border-gray-300 rounded-lg text-gray-700 text-sm focus:ring-indigo-500 focus:border-indigo-500 bg-white shadow-sm cursor-pointer w-auto max-w-[120px] sm:max-w-none">
                            <option value="">æ‰€æœ‰æ¨™ç±¤</option>
                        </select>
                    </div>
                    <div class="hidden sm:flex items-center">
                        <label for="sort-select"
                            class="text-sm text-gray-500 font-medium mr-2 whitespace-nowrap">æ’åºï¼š</label>
                    </div>
                    <select id="sort-select"
                        class="p-2 border border-gray-300 rounded-lg text-gray-700 text-sm focus:ring-indigo-500 focus:border-indigo-500 bg-white shadow-sm cursor-pointer w-auto">
                        <option value="updated_desc">æ›´æ–° (æ–°â†’èˆŠ)</option>
                        <option value="updated_asc">æ›´æ–° (èˆŠâ†’æ–°)</option>
                        <option value="created_desc">å»ºç«‹ (æ–°â†’èˆŠ)</option>
                        <option value="created_asc">å»ºç«‹ (èˆŠâ†’æ–°)</option>
                    </select>
                </div>
            </div>
            <div id="note-list" class="space-y-4">
                <p class="text-gray-500 text-center p-4">æ­£åœ¨è¼‰å…¥ç­†è¨˜...</p>
            </div>
        </div>
    </div>

    <div id="lightbox-modal"
        class="hidden fixed inset-0 z-50 bg-black bg-opacity-90 flex items-center justify-center p-4" aria-modal="true"
        role="dialog">
        <div class="absolute inset-0" onclick="window.closeLightbox()"></div>
        <button class="absolute top-4 right-4 text-white text-4xl font-bold hover:text-gray-300 z-50"
            onclick="window.closeLightbox()">&times;</button>
        <button id="lightbox-prev-btn"
            class="absolute top-1/2 -translate-y-1/2 left-12 z-50 p-4 rounded-full bg-white bg-opacity-20 text-white hover:bg-opacity-40 transition hidden md:block"
            onclick="event.stopPropagation(); window.navigateLightbox(-1);"><svg xmlns="http://www.w3.org/2000/svg"
                class="h-8 w-8" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7" />
            </svg></button>
        <img id="lightbox-image" src="" alt="Full Screen Image" class="lightbox-img rounded-lg shadow-2xl relative z-40"
            onclick="event.stopPropagation()">
        <button id="lightbox-next-btn"
            class="absolute top-1/2 -translate-y-1/2 right-12 z-50 p-4 rounded-full bg-white bg-opacity-20 text-white hover:bg-opacity-40 transition hidden md:block"
            onclick="event.stopPropagation(); window.navigateLightbox(1);"><svg xmlns="http://www.w3.org/2000/svg"
                class="h-8 w-8" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7" />
            </svg></button>
    </div>

    <!-- è³‡æ–™å¤¾ç®¡ç† Modal -->
    <div id="folder-manage-modal"
        class="hidden fixed inset-0 bg-gray-900 bg-opacity-75 flex items-center justify-center p-4 z-50 transition-opacity duration-300">
        <div
            class="bg-white rounded-xl shadow-2xl max-w-md w-full p-6 transform scale-100 transition-transform duration-300 relative">
            <button id="modal-manage-close-x" class="absolute top-4 right-4 text-gray-400 hover:text-gray-600">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24"
                    stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
                </svg>
            </button>
            <h3 class="text-xl font-bold text-gray-800 mb-4">ç®¡ç†å„²å­˜è³‡æ–™å¤¾</h3>

            <!-- è³‡æ–™å¤¾åˆ—è¡¨ -->
            <div id="folder-list" class="max-h-60 overflow-y-auto mb-4 custom-scrollbar">
                <!-- å‹•æ…‹ç”Ÿæˆåˆ—è¡¨ -->
            </div>

            <div class="flex flex-col space-y-3">
                <button id="manage-add-btn"
                    class="w-full py-2 px-4 bg-indigo-600 text-white font-semibold rounded-lg hover:bg-indigo-700 transition duration-150 flex items-center justify-center space-x-2">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24"
                        stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                            d="M12 6v6m0 0v6m0-6h6m-6 0H6" />
                    </svg>
                    <span>æ–°å¢è³‡æ–™å¤¾</span>
                </button>
                <button id="manage-close-btn"
                    class="w-full py-2 px-4 bg-gray-200 text-gray-700 font-semibold rounded-lg hover:bg-gray-300 transition duration-150">
                    é—œé–‰
                </button>
            </div>
        </div>
    </div>

    <div id="custom-modal"
        class="hidden fixed inset-0 bg-gray-900 bg-opacity-75 flex items-center justify-center p-4 z-50 transition-opacity duration-300">
        <div
            class="bg-white rounded-xl shadow-2xl max-w-sm w-full p-6 transform scale-100 transition-transform duration-300">
            <h3 id="modal-title" class="text-xl font-bold text-gray-800 mb-3">è¨Šæ¯</h3>
            <p id="modal-message" class="text-gray-600 mb-6"></p>
            <div class="flex justify-end space-x-3">
                <button id="modal-ok-btn"
                    class="hidden py-2 px-4 bg-indigo-600 text-white font-semibold rounded-lg hover:bg-indigo-700 transition duration-150">ç¢ºå®š</button>
                <button id="modal-cancel-btn"
                    class="hidden py-2 px-4 bg-gray-200 text-gray-700 font-semibold rounded-lg hover:bg-gray-300 transition duration-150">å–æ¶ˆ</button>
                <button id="modal-confirm-btn"
                    class="hidden py-2 px-4 bg-red-600 text-white font-semibold rounded-lg hover:bg-red-700 transition duration-150">ç¢ºèªåˆªé™¤</button>
            </div>
        </div>
    </div>

    <!-- å°‡ Script ç§»è‡³ Body æœ€ä¸‹æ–¹ï¼Œç¢ºä¿ DOM å·²è¼‰å…¥ -->
    <script type="module">
        // --- å…¨åŸŸè®Šæ•¸èˆ‡ç‹€æ…‹ ---
        const DB_NAME = 'LocalNoteDB';
        const STORE_NAME = 'notes';
        const SETTINGS_STORE = 'settings';
        const FOLDERS_STORE = 'folders';
        const DB_VERSION = 3;

        let isEditing = false;
        let currentNewNoteImages = [];
        let currentNewNoteVideos = [];

        // æª”æ¡ˆç³»çµ±æ¨¡å¼è®Šæ•¸
        let directoryHandle = null;
        let isFileSystemMode = false;
        let currentFolderId = null;

        let noteFormContainer, toggleFormBtn, closeFormBtn, sortSelect, tagFilterSelect, noteCountStatus, storageTypeInfo;
        let storageSelect;
        let reconnectBtn;
        let setFolderBtn;

        // --- Lightbox ç‹€æ…‹ ---
        let currentLightboxNoteId = null;
        let currentLightboxImages = [];
        let currentLightboxIndex = -1;
        let touchStartX = 0;
        const SWIPE_THRESHOLD = 50;

        // --- è¼”åŠ©å‡½å¼ ---
        const fileToDataURL = (file) => {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result);
                reader.onerror = (error) => reject(error);
                reader.readAsDataURL(file);
            });
        };

        const dataURLToBlob = (dataURL) => {
            const parts = dataURL.split(';base64,');
            if (parts.length < 2) return new Blob([]);
            const contentType = parts[0].split(':')[1];
            const raw = window.atob(parts[1]);
            const rawLength = raw.length;
            const uInt8Array = new Uint8Array(rawLength);
            for (let i = 0; i < rawLength; ++i) uInt8Array[i] = raw.charCodeAt(i);
            return new Blob([uInt8Array], { type: contentType });
        };

        const getMimeTypeFromFilename = (filename) => {
            const ext = filename.split('.').pop().toLowerCase();
            switch (ext) {
                case 'png': return 'image/png';
                case 'jpg': case 'jpeg': return 'image/jpeg';
                case 'gif': return 'image/gif';
                case 'webp': return 'image/webp';
                case 'mp4': return 'video/mp4';
                case 'webm': return 'video/webm';
                case 'ogg': return 'video/ogg';
                case 'mov': return 'video/quicktime';
                default: return 'image/png';
            }
        };

        const formatDate = (timestamp) => {
            if (!timestamp) return 'æœªçŸ¥æ™‚é–“';
            return new Date(timestamp).toLocaleString('zh-TW', {
                year: 'numeric', month: 'numeric', day: 'numeric',
                hour: '2-digit', minute: '2-digit'
            });
        };

        const getBackupFilename = () => {
            const now = new Date();
            const year = now.getFullYear();
            const month = String(now.getMonth() + 1).padStart(2, '0');
            const day = String(now.getDate()).padStart(2, '0');
            return `Notes_Backup_${year}-${month}-${day}.zip`;
        };

        // --- IndexedDB æ ¸å¿ƒå‡½å¼ ---
        const openNoteDB = () => {
            return new Promise((resolve, reject) => {
                if (!window.indexedDB) { reject('æ‚¨çš„ç€è¦½å™¨ä¸æ”¯æ´ IndexedDBã€‚'); return; }
                const request = indexedDB.open(DB_NAME, DB_VERSION);
                request.onerror = event => { reject('ç„¡æ³•æ‰“é–‹è³‡æ–™åº«ã€‚' + event.target.error?.message); };
                request.onsuccess = event => { resolve(event.target.result); };
                request.onupgradeneeded = event => {
                    const db = event.target.result;
                    if (!db.objectStoreNames.contains(STORE_NAME)) {
                        db.createObjectStore(STORE_NAME, { keyPath: 'id', autoIncrement: true });
                    }
                    if (!db.objectStoreNames.contains(SETTINGS_STORE)) {
                        db.createObjectStore(SETTINGS_STORE);
                    }
                    if (!db.objectStoreNames.contains(FOLDERS_STORE)) {
                        db.createObjectStore(FOLDERS_STORE, { keyPath: 'id' });
                    }
                };
            });
        };

        // --- è¨­å®šå„²å­˜èˆ‡è®€å– ---
        const saveSetting = async (key, value) => {
            const db = await openNoteDB();
            return new Promise((resolve, reject) => {
                const tx = db.transaction([SETTINGS_STORE], 'readwrite');
                tx.objectStore(SETTINGS_STORE).put(value, key);
                tx.oncomplete = resolve;
                tx.onerror = reject;
            });
        };

        const getSetting = async (key) => {
            const db = await openNoteDB();
            return new Promise((resolve, reject) => {
                const tx = db.transaction([SETTINGS_STORE], 'readonly');
                const req = tx.objectStore(SETTINGS_STORE).get(key);
                req.onsuccess = () => resolve(req.result);
                req.onerror = reject;
            });
        };

        // --- è³‡æ–™å¤¾ç®¡ç† ---
        const getSavedFolders = async () => {
            const db = await openNoteDB();
            return new Promise((resolve, reject) => {
                const tx = db.transaction([FOLDERS_STORE], 'readonly');
                const req = tx.objectStore(FOLDERS_STORE).getAll();
                req.onsuccess = () => resolve(req.result);
                req.onerror = reject;
            });
        };

        const saveFolderHandle = async (handle) => {
            const db = await openNoteDB();
            const existingFolders = await getSavedFolders();
            for (const folder of existingFolders) {
                try {
                    if (await handle.isSameEntry(folder.handle)) {
                        if (folder.name !== handle.name) {
                            folder.name = handle.name;
                            folder.handle = handle;
                            await new Promise((resolve, reject) => {
                                const tx = db.transaction([FOLDERS_STORE], 'readwrite');
                                tx.objectStore(FOLDERS_STORE).put(folder);
                                tx.oncomplete = resolve;
                                tx.onerror = reject;
                            });
                        }
                        return folder.id;
                    }
                } catch (err) { console.warn("Handle æª¢æŸ¥å¤±æ•—", err); }
            }
            const folderId = Date.now().toString();
            const folderData = { id: folderId, name: handle.name, handle: handle };
            await new Promise((resolve, reject) => {
                const tx = db.transaction([FOLDERS_STORE], 'readwrite');
                tx.objectStore(FOLDERS_STORE).put(folderData);
                tx.oncomplete = resolve;
                tx.onerror = reject;
            });
            return folderId;
        };

        // æ–°å¢ï¼šåˆªé™¤è³‡æ–™å¤¾
        const removeFolderHandle = async (id) => {
            const db = await openNoteDB();
            return new Promise((resolve, reject) => {
                const tx = db.transaction([FOLDERS_STORE], 'readwrite');
                tx.objectStore(FOLDERS_STORE).delete(id);
                tx.oncomplete = resolve;
                tx.onerror = reject;
            });
        };

        const getFolderHandleById = async (id) => {
            const db = await openNoteDB();
            return new Promise((resolve, reject) => {
                const tx = db.transaction([FOLDERS_STORE], 'readonly');
                const req = tx.objectStore(FOLDERS_STORE).get(id);
                req.onsuccess = () => resolve(req.result ? req.result.handle : null);
                req.onerror = reject;
            });
        };

        const getNotesIDB = async () => {
            const db = await openNoteDB();
            const transaction = db.transaction([STORE_NAME], 'readonly');
            const store = transaction.objectStore(STORE_NAME);
            return new Promise((resolve, reject) => {
                const request = store.getAll();
                request.onsuccess = () => resolve(request.result);
                request.onerror = (e) => reject(e.target.error);
            });
        };

        const getNoteByIdIDB = async (noteId) => {
            const db = await openNoteDB();
            return new Promise((resolve, reject) => {
                const request = db.transaction([STORE_NAME], 'readonly').objectStore(STORE_NAME).get(noteId);
                request.onsuccess = () => resolve(request.result);
                request.onerror = (e) => reject(e.target.error);
            });
        };

        // --- File System Access API å‡½å¼ ---

        const verifyPermission = async (fileHandle, readWrite) => {
            const options = {};
            if (readWrite) options.mode = 'readwrite';
            if ((await fileHandle.queryPermission(options)) === 'granted') return true;
            if ((await fileHandle.requestPermission(options)) === 'granted') return true;
            return false;
        };

        const setLocalFolder = async () => {
            if (!('showDirectoryPicker' in window)) {
                showModal('ä¸æ”¯æ´', 'æ‚¨çš„ç€è¦½å™¨æˆ–è£ç½®ï¼ˆå¦‚æ‰‹æ©Ÿï¼‰ä¸æ”¯æ´ç›´æ¥å­˜å–æœ¬æ©Ÿæª”æ¡ˆç³»çµ±ã€‚');
                await refreshStorageSelectUI(isFileSystemMode ? currentFolderId : 'idb');
                return;
            }
            try {
                const handle = await window.showDirectoryPicker();
                const folderId = await saveFolderHandle(handle);
                directoryHandle = handle;
                isFileSystemMode = true;
                currentFolderId = folderId;

                await saveSetting('activeMode', folderId);
                await loadNotes();

                closeManageModal();
                showModal('è¨­å®šæˆåŠŸ', `å·²åˆ‡æ›è‡³æœ¬æ©Ÿè³‡æ–™å¤¾ï¼šã€Œ${handle.name}ã€ã€‚`);
            } catch (e) {
                if (e.name !== 'AbortError') showModal('éŒ¯èª¤', 'ç„¡æ³•å­˜å–è³‡æ–™å¤¾: ' + e.message);
                await refreshStorageSelectUI(isFileSystemMode ? currentFolderId : 'idb');
            }
        };

        // é‡é€£é‚è¼¯
        const reconnectLocalFolder = async () => {
            if (!directoryHandle) return;
            try {
                if (await verifyPermission(directoryHandle, true)) {
                    if (reconnectBtn) reconnectBtn.classList.add('hidden');
                    updateStatusText(`ç›®å‰ä½¿ç”¨ï¼š${directoryHandle.name}`, "text-green-700", "bg-green-100");
                    await loadNotes();
                } else {
                    showModal('æ¬Šé™è¢«æ‹’', 'æ‚¨æ‹’çµ•äº†è³‡æ–™å¤¾å­˜å–æ¬Šé™ï¼Œç„¡æ³•è¼‰å…¥ç­†è¨˜ã€‚');
                }
            } catch (e) {
                console.error(e);
                showModal('é‡é€£å¤±æ•—', 'ç„¡æ³•é‡æ–°é€£çµè³‡æ–™å¤¾ã€‚');
            }
        };

        const initStorage = async () => {
            try {
                const activeMode = await getSetting('activeMode') || 'idb';
                await refreshStorageSelectUI(activeMode);

                if (activeMode !== 'idb') {
                    const handle = await getFolderHandleById(activeMode);
                    if (handle) {
                        directoryHandle = handle;
                        isFileSystemMode = true;
                        currentFolderId = activeMode;

                        const hasPermission = await handle.queryPermission({ mode: 'readwrite' }) === 'granted';

                        if (hasPermission) {
                            await loadNotes();
                        } else {
                            checkSavedFolder(handle, activeMode);
                            updateStatusText(`ç›®å‰é¸å®šï¼š${handle.name} (éœ€æˆæ¬Š)`, "text-orange-600", "bg-orange-100");
                            const noteList = document.getElementById('note-list');
                            if (noteList) noteList.innerHTML = '<p class="text-gray-500 text-center p-4">è«‹é»æ“Šä¸Šæ–¹ã€Œé‡é€£è³‡æ–™å¤¾ã€æŒ‰éˆ•ä»¥æˆæ¬Šå­˜å–ã€‚</p>';
                            if (noteCountStatus) noteCountStatus.textContent = 'ç­‰å¾…æˆæ¬Š...';
                        }
                    } else {
                        await switchToIDB();
                    }
                } else {
                    await switchToIDB();
                }
            } catch (e) {
                console.error("Init Error", e);
                await switchToIDB();
            }
        };

        const switchToIDB = async () => {
            isFileSystemMode = false;
            directoryHandle = null;
            currentFolderId = 'idb';
            await saveSetting('activeMode', 'idb');
            await refreshStorageSelectUI('idb');
            await loadNotes();
            if (reconnectBtn) reconnectBtn.classList.add('hidden');
        };

        const refreshStorageSelectUI = async (activeId) => {
            const select = document.getElementById('storage-selector');
            if (!select) return;
            select.innerHTML = '';

            // é¸é … 1: ç€è¦½å™¨å„²å­˜
            const optIdb = document.createElement('option');
            optIdb.value = 'idb';
            optIdb.text = 'ç€è¦½å™¨è³‡æ–™åº« (IndexedDB)';
            select.add(optIdb);

            // åˆ—å‡ºå·²å„²å­˜çš„è³‡æ–™å¤¾
            const folders = await getSavedFolders();
            if (folders.length > 0) {
                const group = document.createElement('optgroup');
                group.label = "å·²å„²å­˜çš„è³‡æ–™å¤¾";

                folders.forEach(folder => {
                    const opt = document.createElement('option');
                    opt.value = folder.id;
                    opt.text = `ğŸ“ ${folder.name}`;
                    group.appendChild(opt);
                });
                select.add(group);
            }

            // é¸é …: ç®¡ç†è³‡æ–™å¤¾
            const optManage = document.createElement('option');
            optManage.value = 'fs_manage';
            optManage.text = 'âš™ï¸ ç®¡ç†å„²å­˜è³‡æ–™å¤¾...';
            select.add(optManage);

            // è¨­å®šé¸ä¸­é …
            if (activeId === 'idb' || !activeId) {
                select.value = 'idb';
                updateStatusText("ç›®å‰ä½¿ç”¨ï¼šç€è¦½å™¨è³‡æ–™åº«", "text-gray-500", "bg-white");
                if (reconnectBtn) reconnectBtn.classList.add('hidden');
            } else if (activeId && activeId !== 'fs_manage') {
                select.value = activeId;
                const folder = folders.find(f => f.id === activeId);
                const name = folder ? folder.name : 'æœªçŸ¥è³‡æ–™å¤¾';

                if (reconnectBtn && reconnectBtn.classList.contains('hidden')) {
                    updateStatusText(`ç›®å‰ä½¿ç”¨ï¼š${name}`, "text-green-700", "bg-green-100");
                }
            }

            updateSetFolderButton();
        };

        const updateStatusText = (text, textColor, bgColor) => {
            if (storageTypeInfo) {
                storageTypeInfo.textContent = text;
                storageTypeInfo.className = `text-sm ${textColor} mt-2 p-2 ${bgColor} inline-block rounded-full shadow-inner font-bold`;
            }
        };

        const updateSetFolderButton = () => {
            if (!setFolderBtn) return;
            if (isFileSystemMode) {
                setFolderBtn.textContent = "åˆ‡æ›å›ç€è¦½å™¨å„²å­˜";
                setFolderBtn.classList.replace('bg-blue-600', 'bg-gray-500');
            } else {
                setFolderBtn.textContent = "è¨­å®šå„²å­˜è³‡æ–™å¤¾";
                setFolderBtn.classList.replace('bg-gray-500', 'bg-blue-600');
            }
        };

        const handleSetFolderClick = () => {
            if (isFileSystemMode) {
                location.reload();
            } else {
                setLocalFolder();
            }
        };

        // ç®¡ç†è¦–çª—é‚è¼¯
        const openManageModal = async () => {
            const modal = document.getElementById('folder-manage-modal');
            const listContainer = document.getElementById('folder-list');
            if (listContainer) listContainer.innerHTML = '';

            const folders = await getSavedFolders();
            if (folders.length === 0) {
                if (listContainer) listContainer.innerHTML = '<p class="text-gray-500 text-center py-4">å°šæœªè¨­å®šä»»ä½•è³‡æ–™å¤¾ã€‚</p>';
            } else {
                folders.forEach(folder => {
                    const item = document.createElement('div');
                    item.className = 'flex justify-between items-center p-3 bg-gray-50 rounded-lg border border-gray-200 mb-2';

                    const info = document.createElement('div');
                    info.className = 'flex items-center space-x-2 overflow-hidden';
                    info.innerHTML = `<span class="text-2xl">ğŸ“</span><span class="font-medium truncate" title="${folder.name}">${folder.name}</span>`;
                    if (folder.id === currentFolderId) {
                        info.innerHTML += `<span class="text-xs bg-green-100 text-green-700 px-2 py-0.5 rounded-full ml-2 flex-shrink-0">ä½¿ç”¨ä¸­</span>`;
                    }

                    const delBtn = document.createElement('button');
                    delBtn.className = 'text-red-500 hover:text-red-700 p-2 rounded hover:bg-red-50 transition';
                    delBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" /></svg>`;
                    delBtn.onclick = () => handleDeleteFolder(folder.id, folder.name);

                    item.appendChild(info);
                    item.appendChild(delBtn);
                    listContainer.appendChild(item);
                });
            }
            if (modal) modal.classList.remove('hidden');
        };

        const closeManageModal = () => {
            const modal = document.getElementById('folder-manage-modal');
            if (modal) modal.classList.add('hidden');
            // é—œé–‰æ™‚ï¼Œç¢ºä¿ dropdown é¸å›æ­£ç¢ºçš„å€¼
            refreshStorageSelectUI(isFileSystemMode ? currentFolderId : 'idb');
        };

        const handleDeleteFolder = async (id, name) => {
            showConfirmModal('åˆªé™¤è³‡æ–™å¤¾è¨­å®š', `ç¢ºå®šè¦ç§»é™¤è³‡æ–™å¤¾ã€Œ${name}ã€çš„è¨­å®šå—ï¼Ÿ\n(ä¸æœƒåˆªé™¤ç¡¬ç¢Ÿä¸Šçš„æª”æ¡ˆ)`, async () => {
                await removeFolderHandle(id);

                // å¦‚æœåˆªé™¤çš„æ˜¯ç•¶å‰ä½¿ç”¨çš„è³‡æ–™å¤¾ï¼Œå¼·åˆ¶åˆ‡å› IDB
                if (id === currentFolderId) {
                    showModal('æ³¨æ„', 'æ‚¨ç§»é™¤äº†ç•¶å‰æ­£åœ¨ä½¿ç”¨çš„è³‡æ–™å¤¾è¨­å®šï¼Œç³»çµ±å°‡è‡ªå‹•åˆ‡æ›å›ç€è¦½å™¨å„²å­˜æ¨¡å¼ã€‚');
                    await switchToIDB();
                }

                // é‡æ–°æ¸²æŸ“ç®¡ç†åˆ—è¡¨
                openManageModal();
                // èƒŒæ™¯æ›´æ–° dropdown
                refreshStorageSelectUI(isFileSystemMode ? currentFolderId : 'idb');
            }, 'ç§»é™¤è¨­å®š');
        };

        const handleStorageChange = async (e) => {
            const value = e.target.value;

            if (value === 'idb') {
                await switchToIDB();
            } else if (value === 'fs_manage') {
                openManageModal();
                // ä¸è¦ç«‹å³åˆ‡æ› valueï¼Œç­‰ modal æ“ä½œå®Œ
            } else {
                const folderId = value;
                const handle = await getFolderHandleById(folderId);

                if (handle) {
                    directoryHandle = handle;
                    isFileSystemMode = true;
                    currentFolderId = folderId;
                    await saveSetting('activeMode', folderId);
                    updateStatusText(`ç›®å‰ä½¿ç”¨ï¼š${handle.name}`, "text-green-700", "bg-green-100");

                    if (await verifyPermission(handle, true)) {
                        if (reconnectBtn) reconnectBtn.classList.add('hidden');
                        await loadNotes();
                    } else {
                        checkSavedFolder(handle, folderId);
                        updateStatusText(`ç›®å‰é¸å®šï¼š${handle.name} (éœ€æˆæ¬Š)`, "text-orange-600", "bg-orange-100");
                        const noteList = document.getElementById('note-list');
                        if (noteList) noteList.innerHTML = '<p class="text-gray-500 text-center p-4">è«‹é»æ“Šä¸Šæ–¹ã€Œé‡é€£è³‡æ–™å¤¾ã€æŒ‰éˆ•ä»¥æˆæ¬Šå­˜å–ã€‚</p>';
                        if (noteCountStatus) noteCountStatus.textContent = 'ç­‰å¾…æˆæ¬Š...';
                    }
                } else {
                    showModal('éŒ¯èª¤', 'æ‰¾ä¸åˆ°è©²è³‡æ–™å¤¾è¨­å®šã€‚');
                    await switchToIDB();
                }
            }
            updateSetFolderButton();
        };

        const checkSavedFolder = (handle, id) => {
            if (reconnectBtn) {
                reconnectBtn.classList.remove('hidden');
                reconnectBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" /></svg><span>é‡é€£/æˆæ¬Š: ${handle.name}</span>`;
                reconnectBtn.onclick = async () => {
                    if (await verifyPermission(handle, true)) {
                        reconnectBtn.classList.add('hidden');
                        updateStatusText(`ç›®å‰ä½¿ç”¨ï¼š${handle.name}`, "text-green-700", "bg-green-100");
                        await loadNotes();
                    } else {
                        showModal('æç¤º', 'éœ€è¦æˆæ¬Šæ‰èƒ½è®€å–æ­¤è³‡æ–™å¤¾çš„ç­†è¨˜ã€‚');
                    }
                };
            }
        };

        const getNotesFromFS = async () => {
            if (!directoryHandle) return [];
            try {
                let fileHandle;
                try { fileHandle = await directoryHandle.getFileHandle('notes.json', { create: false }); }
                catch (e) { return []; }
                const file = await fileHandle.getFile();
                const content = await file.text();
                const notes = JSON.parse(content);
                const imagesDir = await directoryHandle.getDirectoryHandle('images', { create: true }).catch(() => null);
                const videosDir = await directoryHandle.getDirectoryHandle('videos', { create: true }).catch(() => null);
                for (const note of notes) {
                    note.images = [];
                    note.videos = [];
                    if (imagesDir && note.image_files && Array.isArray(note.image_files)) {
                        try {
                            const noteDir = await imagesDir.getDirectoryHandle(String(note.id), { create: false });
                            for (const filename of note.image_files) {
                                try {
                                    const imgHandle = await noteDir.getFileHandle(filename, { create: false });
                                    const base64 = await fileToDataURL(await imgHandle.getFile());
                                    note.images.push(base64);
                                } catch (err) { console.warn(`ç„¡æ³•è®€å–åœ–ç‰‡ ${filename}`, err); }
                            }
                        } catch (err) { }
                    }
                    if (videosDir && note.video_files && Array.isArray(note.video_files)) {
                        try {
                            const noteDir = await videosDir.getDirectoryHandle(String(note.id), { create: false });
                            for (const filename of note.video_files) {
                                try {
                                    const vidHandle = await noteDir.getFileHandle(filename, { create: false });
                                    const base64 = await fileToDataURL(await vidHandle.getFile());
                                    note.videos.push(base64);
                                } catch (err) { console.warn(`ç„¡æ³•è®€å–å½±ç‰‡ ${filename}`, err); }
                            }
                        } catch (err) { }
                    }
                }
                return notes;
            } catch (e) { console.error("FS Read Error:", e); return []; }
        };

        const saveNoteToFS = async (noteData) => {
            if (!directoryHandle) return;
            let currentNotes = await getNotesFromFS();
            const existingIndex = currentNotes.findIndex(n => n.id === noteData.id);
            const imagesBase64 = noteData.images || [];
            const videosBase64 = noteData.videos || [];
            const imageFilenames = [];
            const videoFilenames = [];
            if (imagesBase64.length > 0) {
                try {
                    const imagesDir = await directoryHandle.getDirectoryHandle('images', { create: true });
                    const noteDir = await imagesDir.getDirectoryHandle(String(noteData.id), { create: true });
                    for (let i = 0; i < imagesBase64.length; i++) {
                        const base64 = imagesBase64[i];
                        const mimeTypeMatch = base64.match(/data:([^;]+);base64,/);
                        const ext = (mimeTypeMatch ? mimeTypeMatch[1] : 'image/png').split('/')[1] || 'png';
                        const filename = `image_${i}.${ext}`;
                        const fileHandle = await noteDir.getFileHandle(filename, { create: true });
                        const writable = await fileHandle.createWritable();
                        await writable.write(dataURLToBlob(base64));
                        await writable.close();
                        imageFilenames.push(filename);
                    }
                } catch (e) { showModal('éŒ¯èª¤', 'å¯«å…¥åœ–ç‰‡æª”æ¡ˆå¤±æ•—'); return; }
            }
            if (videosBase64.length > 0) {
                try {
                    const videosDir = await directoryHandle.getDirectoryHandle('videos', { create: true });
                    const noteDir = await videosDir.getDirectoryHandle(String(noteData.id), { create: true });
                    for (let i = 0; i < videosBase64.length; i++) {
                        const base64 = videosBase64[i];
                        const mimeTypeMatch = base64.match(/data:([^;]+);base64,/);
                        const mime = mimeTypeMatch ? mimeTypeMatch[1] : 'video/mp4';
                        let ext = mime.split('/')[1] || 'mp4';
                        if (ext === 'quicktime') ext = 'mov';
                        const filename = `video_${i}.${ext}`;
                        const fileHandle = await noteDir.getFileHandle(filename, { create: true });
                        const writable = await fileHandle.createWritable();
                        await writable.write(dataURLToBlob(base64));
                        await writable.close();
                        videoFilenames.push(filename);
                    }
                } catch (e) { showModal('éŒ¯èª¤', 'å¯«å…¥å½±ç‰‡æª”æ¡ˆå¤±æ•—'); return; }
            }
            const noteToSave = {
                id: noteData.id, title: noteData.title, content: noteData.content,
                created_at: noteData.created_at, updated_at: noteData.updated_at,
                timestamp: noteData.timestamp, image_files: imageFilenames, video_files: videoFilenames,
                tags: noteData.tags || [] // Save tags
            };
            if (existingIndex >= 0) currentNotes[existingIndex] = noteToSave;
            else currentNotes.push(noteToSave);
            const notesForJson = currentNotes.map(n => { const { images, videos, ...rest } = n; return rest; });
            const fileHandle = await directoryHandle.getFileHandle('notes.json', { create: true });
            const writable = await fileHandle.createWritable();
            await writable.write(JSON.stringify(notesForJson, null, 2));
            await writable.close();
        };

        const deleteNoteFromFS = async (noteId) => {
            if (!directoryHandle) return;
            let currentNotes = await getNotesFromFS();
            const newNotes = currentNotes.filter(n => n.id !== noteId);
            const notesForJson = newNotes.map(n => { const { images, videos, ...rest } = n; return rest; });
            const fileHandle = await directoryHandle.getFileHandle('notes.json', { create: true });
            const writable = await fileHandle.createWritable();
            await writable.write(JSON.stringify(notesForJson, null, 2));
            await writable.close();
            try {
                const imagesDir = await directoryHandle.getDirectoryHandle('images', { create: false });
                await imagesDir.removeEntry(String(noteId), { recursive: true });
            } catch (e) { }
            try {
                const videosDir = await directoryHandle.getDirectoryHandle('videos', { create: false });
                await videosDir.removeEntry(String(noteId), { recursive: true });
            } catch (e) { }
        };

        const importFromZipToFS = async (zipFile) => {
            if (!directoryHandle) return;
            const zip = new JSZip();
            try {
                const content = await zip.loadAsync(zipFile);
                const notesJsonFile = content.file('notes.json');
                if (!notesJsonFile) throw new Error("ZIP ä¸­æ‰¾ä¸åˆ° notes.json");
                const notesText = await notesJsonFile.async('text');
                JSON.parse(notesText);
                const notesHandle = await directoryHandle.getFileHandle('notes.json', { create: true });
                const writable = await notesHandle.createWritable();
                await writable.write(notesText);
                await writable.close();
                const imagesFolderHandle = await directoryHandle.getDirectoryHandle('images', { create: true });
                const promises = [];
                content.forEach((relativePath, zipEntry) => {
                    if (zipEntry.dir) return;
                    const parts = relativePath.split('/');
                    if (parts.length >= 3 && parts[0] === 'images') {
                        const noteId = parts[1];
                        const filename = parts[parts.length - 1];
                        const p = (async () => {
                            try {
                                const noteDirHandle = await imagesFolderHandle.getDirectoryHandle(noteId, { create: true });
                                const fileHandle = await noteDirHandle.getFileHandle(filename, { create: true });
                                const blob = await zipEntry.async('blob');
                                const writableImg = await fileHandle.createWritable();
                                await writableImg.write(blob);
                                await writableImg.close();
                            } catch (err) { console.warn("è§£å£“ç¸®åœ–ç‰‡å¤±æ•—", relativePath, err); }
                        })();
                        promises.push(p);
                    } else if (parts.length >= 3 && parts[0] === 'videos') {
                        const noteId = parts[1];
                        const filename = parts[parts.length - 1];
                        const p = (async () => {
                            try {
                                const videosFolderHandle = await directoryHandle.getDirectoryHandle('videos', { create: true });
                                const noteDirHandle = await videosFolderHandle.getDirectoryHandle(noteId, { create: true });
                                const fileHandle = await noteDirHandle.getFileHandle(filename, { create: true });
                                const blob = await zipEntry.async('blob');
                                const writableVid = await fileHandle.createWritable();
                                await writableVid.write(blob);
                                await writableVid.close();
                            } catch (err) { console.warn("è§£å£“ç¸®å½±ç‰‡å¤±æ•—", relativePath, err); }
                        })();
                        promises.push(p);
                    }
                });
                await Promise.all(promises);
                showModal('æˆåŠŸ', 'åŒ¯å…¥ï¼ˆè§£å£“ç¸®ï¼‰å®Œæˆï¼è³‡æ–™å·²å¯«å…¥æœ¬æ©Ÿè³‡æ–™å¤¾ã€‚');
                await loadNotes();
            } catch (e) { showModal('éŒ¯èª¤', 'åŒ¯å…¥å¤±æ•—: ' + e.message); }
        };

        // --- çµ±ä¸€è³‡æ–™å­˜å–å±¤ ---
        const getNotes = async () => (isFileSystemMode ? await getNotesFromFS() : await getNotesIDB());
        const getNoteById = async (noteId) => {
            if (isFileSystemMode) return (await getNotesFromFS()).find(n => n.id === noteId);
            return await getNoteByIdIDB(noteId);
        };

        const createNote = async (title, content) => {
            if (!title || !content) { showModal('è­¦å‘Š', 'æ¨™é¡Œèˆ‡å…§å®¹ä¸èƒ½ç‚ºç©ºï¼'); return; }
            const now = Date.now();
            // Get tags
            const tagsInput = document.getElementById('note-tags');
            let tags = [];
            if (tagsInput && tagsInput.value) {
                tags = tagsInput.value.split(/[,ï¼Œ]/).map(t => t.trim()).filter(t => t.length > 0);
            }

            const newNote = {
                title, content, created_at: now, updated_at: now, timestamp: now, images: currentNewNoteImages, videos: currentNewNoteVideos, tags: tags
            };
            try {
                if (isFileSystemMode) { newNote.id = now; await saveNoteToFS(newNote); }
                else {
                    const db = await openNoteDB();
                    const tx = db.transaction([STORE_NAME], 'readwrite');
                    tx.objectStore(STORE_NAME).add(newNote);
                    await new Promise(resolve => tx.oncomplete = resolve);
                }
                loadNotes();
                document.getElementById('note-title').value = '';
                document.getElementById('note-content').value = '';
                if (tagsInput) tagsInput.value = ''; // Clear tags input
                resetNewNoteMedia();
                hideNoteForm();
            } catch (e) { showModal('éŒ¯èª¤', 'æ–°å¢ç­†è¨˜å¤±æ•—ï¼š' + e); }
        };

        const updateNote = async (noteId, newTitle, newContent, newImagesArray, newVideosArray, newTags) => {
            try {
                let noteData = await getNoteById(noteId);
                if (!noteData) throw new Error("Note not found");
                noteData.title = newTitle; noteData.content = newContent;
                noteData.updated_at = Date.now(); noteData.timestamp = Date.now();
                noteData.images = newImagesArray; delete noteData.image;
                noteData.videos = newVideosArray;
                noteData.tags = newTags || []; // Update tags

                if (isFileSystemMode) await saveNoteToFS(noteData);
                else {
                    const db = await openNoteDB();
                    const tx = db.transaction([STORE_NAME], 'readwrite');
                    tx.objectStore(STORE_NAME).put(noteData);
                    await new Promise(resolve => tx.oncomplete = resolve);
                }
                loadNotes(); isEditing = false;
            } catch (e) { showModal('éŒ¯èª¤', 'æ›´æ–°ç­†è¨˜å¤±æ•—ï¼š' + e); }
        };

        const deleteNote = async (noteId) => {
            try {
                if (isFileSystemMode) await deleteNoteFromFS(noteId);
                else {
                    const db = await openNoteDB();
                    const tx = db.transaction([STORE_NAME], 'readwrite');
                    tx.objectStore(STORE_NAME).delete(noteId);
                    await new Promise(resolve => tx.oncomplete = resolve);
                }
                loadNotes();
            } catch (e) { showModal('éŒ¯èª¤', 'åˆªé™¤å¤±æ•—ï¼š' + e); }
        };

        // --- Lightbox é‚è¼¯ ---
        window.openLightbox = async (noteId, initialIndex) => {
            const noteData = await getNoteById(noteId);
            if (!noteData || !noteData.images || noteData.images.length === 0) return;
            currentLightboxNoteId = noteId;
            currentLightboxImages = noteData.images;
            currentLightboxIndex = initialIndex;
            const modal = document.getElementById('lightbox-modal');
            const img = document.getElementById('lightbox-image');
            window.updateLightboxImage();
            document.addEventListener('keydown', window.handleLightboxKeydown);
            img.addEventListener('touchstart', handleTouchStart);
            img.addEventListener('touchmove', handleTouchMove);
            img.addEventListener('touchend', handleTouchEnd);
            modal.classList.remove('hidden');
        };

        window.closeLightbox = () => {
            document.getElementById('lightbox-modal').classList.add('hidden');
            document.removeEventListener('keydown', window.handleLightboxKeydown);
            const img = document.getElementById('lightbox-image');
            img.removeEventListener('touchstart', handleTouchStart);
            img.removeEventListener('touchmove', handleTouchMove);
            img.removeEventListener('touchend', handleTouchEnd);
            currentLightboxNoteId = null; currentLightboxImages = []; currentLightboxIndex = -1;
        };

        window.updateLightboxImage = () => {
            if (currentLightboxIndex < 0 || currentLightboxIndex >= currentLightboxImages.length) return;
            const img = document.getElementById('lightbox-image');
            const prevBtn = document.getElementById('lightbox-prev-btn');
            const nextBtn = document.getElementById('lightbox-next-btn');
            img.src = currentLightboxImages[currentLightboxIndex];
            prevBtn.classList.toggle('md:hidden', currentLightboxIndex <= 0);
            nextBtn.classList.toggle('md:hidden', currentLightboxIndex >= currentLightboxImages.length - 1);
        };

        window.navigateLightbox = (dir) => {
            let newIndex = currentLightboxIndex + dir;
            if (newIndex >= 0 && newIndex < currentLightboxImages.length) {
                currentLightboxIndex = newIndex;
                window.updateLightboxImage();
            }
        };
        window.handleLightboxKeydown = (e) => {
            if (e.key === 'Escape') window.closeLightbox();
            else if (e.key === 'ArrowLeft') { e.preventDefault(); window.navigateLightbox(-1); }
            else if (e.key === 'ArrowRight') { e.preventDefault(); window.navigateLightbox(1); }
        };

        let isMoving = false;
        const handleTouchStart = (e) => { if (currentLightboxImages.length <= 1) return; touchStartX = e.touches[0].clientX; isMoving = false; };
        const handleTouchMove = (e) => { if (currentLightboxImages.length <= 1) return; if (Math.abs(e.touches[0].clientX - touchStartX) > 10) { isMoving = true; e.preventDefault(); } };
        const handleTouchEnd = (e) => { if (currentLightboxImages.length <= 1) return; const delta = e.changedTouches[0].clientX - touchStartX; if (Math.abs(delta) > SWIPE_THRESHOLD && isMoving) window.navigateLightbox(delta > 0 ? -1 : 1); isMoving = false; };

        // --- ä»‹é¢ç›¸é—œå‡½å¼ ---
        const hideNoteForm = () => {
            if (noteFormContainer) {
                noteFormContainer.classList.add('hidden');
            }
            if (toggleFormBtn) {
                toggleFormBtn.textContent = 'æ–°å¢è¨˜äº‹';
            }
        };

        const toggleNoteForm = () => {
            if (isEditing) { showModal('è­¦å‘Š', 'è«‹å…ˆå®Œæˆç•¶å‰ç­†è¨˜çš„ç·¨è¼¯æˆ–å„²å­˜ã€‚'); return; }
            if (noteFormContainer) {
                if (noteFormContainer.classList.toggle('hidden')) {
                    if (toggleFormBtn) toggleFormBtn.textContent = 'æ–°å¢è¨˜äº‹';
                } else {
                    document.getElementById('note-title').focus();
                    if (toggleFormBtn) toggleFormBtn.textContent = 'éš±è—è¡¨å–®';
                }
            }
        };

        const renderNewNoteImagesPreview = () => {
            const previewContainer = document.getElementById('image-preview');
            if (previewContainer) {
                previewContainer.className = 'image-preview-grid mb-3';
                previewContainer.innerHTML = '';
                if (currentNewNoteImages.length === 0) return;
                currentNewNoteImages.forEach((img, idx) => {
                    const wrapper = document.createElement('div');
                    wrapper.className = 'image-thumbnail';
                    wrapper.innerHTML = `<img src="${img}">`;
                    const removeBtn = document.createElement('div');
                    removeBtn.className = 'remove-img-btn'; removeBtn.innerHTML = 'âœ•';
                    removeBtn.onclick = () => { currentNewNoteImages.splice(idx, 1); renderNewNoteImagesPreview(); };
                    wrapper.appendChild(removeBtn); previewContainer.appendChild(wrapper);
                });
            }
        };

        const renderNewNoteVideosPreview = () => {
            const previewContainer = document.getElementById('video-preview');
            if (previewContainer) {
                previewContainer.className = 'image-preview-grid mb-3';
                previewContainer.innerHTML = '';
                if (currentNewNoteVideos.length === 0) return;
                currentNewNoteVideos.forEach((vid, idx) => {
                    const wrapper = document.createElement('div');
                    wrapper.className = 'image-thumbnail relative';
                    wrapper.innerHTML = `<video src="${vid}" controls class="w-full h-full object-cover"></video>`;
                    const removeBtn = document.createElement('div');
                    removeBtn.className = 'remove-img-btn'; removeBtn.innerHTML = 'âœ•';
                    removeBtn.onclick = () => { currentNewNoteVideos.splice(idx, 1); renderNewNoteVideosPreview(); };
                    wrapper.appendChild(removeBtn); previewContainer.appendChild(wrapper);
                });
            }
        };

        const resetNewNoteMedia = () => {
            currentNewNoteImages = [];
            currentNewNoteVideos = [];
            renderNewNoteImagesPreview();
            renderNewNoteVideosPreview();
            const imgInput = document.getElementById('image-input');
            if (imgInput) imgInput.value = '';
            const videoInput = document.getElementById('video-input');
            if (videoInput) videoInput.value = '';
        };

        const createNoteElement = ({ id, title, content, createdAt, updatedAt, images, videos, tags }) => {
            const noteCard = document.createElement('div');
            noteCard.className = 'note-card bg-white p-4 rounded-xl shadow-lg hover:shadow-xl transition duration-300 border-l-4 border-indigo-500 mb-4';
            noteCard.dataset.noteId = id;

            let tagsHtml = '';
            if (tags && tags.length > 0) {
                tagsHtml = `<div class="flex flex-wrap gap-1 mb-2 mt-1">`;
                tags.forEach(tag => {
                    tagsHtml += `<span class="tag-badge">${tag}</span>`;
                });
                tagsHtml += `</div>`;
            }

            let imagesHtml = '';
            if (images && images.length > 0) {
                imagesHtml = `<div class="flex space-x-3 overflow-x-auto custom-scrollbar mb-3 note-image-display py-1 pb-3">`;
                images.forEach((img, index) => {
                    imagesHtml += `<div class="flex-shrink-0 w-28 h-28 rounded-lg overflow-hidden border border-gray-300 shadow-sm group">
                        <img src="${img}" data-image-index="${index}" class="w-full h-full object-cover cursor-zoom-in hover:opacity-90 transition lightbox-trigger" alt="ç­†è¨˜åœ–ç‰‡">
                    </div>`;
                });
                imagesHtml += `</div>`;
            }

            let videosHtml = '';
            if (videos && videos.length > 0) {
                videosHtml = `<div class="flex space-x-3 overflow-x-auto custom-scrollbar mb-3 note-video-display py-1 pb-3">`;
                videos.forEach((vid) => {
                    videosHtml += `<div class="flex-shrink-0 w-48 h-32 rounded-lg overflow-hidden border border-gray-300 shadow-sm group relative">
                        <video src="${vid}" controls class="w-full h-full object-cover"></video>
                    </div>`;
                });
                videosHtml += `</div>`;
            }

            const createdStr = formatDate(createdAt);
            const updatedStr = formatDate(updatedAt);
            let dateHtml = `<div class="text-xs text-gray-400 border-t pt-2 mt-2 space-y-1">`;
            dateHtml += `<div>å»ºç«‹ï¼š${createdStr}</div>`;
            if (updatedAt && Math.abs(updatedAt - createdAt) > 1000) dateHtml += `<div>æ›´æ–°ï¼š${updatedStr}</div>`;
            dateHtml += `</div>`;

            noteCard.innerHTML = `
                <div class="header flex justify-between items-start mb-2">
                    <h3 class="text-xl font-bold text-gray-800 break-words w-4/5" data-field="title">${title}</h3>
                    <div class="actions flex space-x-2">
                        <button class="edit-btn p-2 rounded-full bg-blue-100 text-blue-600 hover:bg-blue-200 transition duration-150" aria-label="ç·¨è¼¯"><svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path d="M13.586 3.586a2 2 0 112.828 2.828l-.793.793-2.828-2.828.793-.793zm-7.586 10.586a2 2 0 01-3.376 0L1 14.5V17h2.5l-.586-.586a2 2 0 010-3.376zM15 6l-3-3L5 11l-2.5 5.5.5 1.5 1.5.5L11 15l7-7-3-3z"/></svg></button>
                        <button class="delete-btn p-2 rounded-full bg-red-100 text-red-600 hover:bg-red-200 transition duration-150" aria-label="åˆªé™¤" data-action="delete"><svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 012 0v6a1 1 0 11-2 0V8zm4 0a1 1 0 112 0v6a1 1 0 11-2 0V8z" clip-rule="evenodd" /></svg></button>
                    </div>
                </div>
                ${tagsHtml}
                <p class="text-gray-600 mb-3 whitespace-pre-wrap max-h-40 overflow-hidden" data-field="content">${content}</p>
                ${imagesHtml}
                ${videosHtml}
                ${dateHtml}
            `;

            noteCard.querySelectorAll('.lightbox-trigger').forEach(img => {
                img.addEventListener('click', (e) => { e.stopPropagation(); window.openLightbox(Number(id), Number(img.dataset.imageIndex)); });
            });
            noteCard.querySelector('.delete-btn').addEventListener('click', () => showConfirmModal('ç¢ºèªåˆªé™¤', 'æ‚¨ç¢ºå®šè¦åˆªé™¤é€™æ¢ç­†è¨˜å—ï¼Ÿ', () => deleteNote(Number(id)), 'ç¢ºèªåˆªé™¤'));

            const editButton = noteCard.querySelector('.edit-btn');
            editButton.addEventListener('click', async (e) => {
                const targetBtn = e.currentTarget;
                if (!isEditing) {
                    hideNoteForm();
                    const noteData = await getNoteById(id);
                    if (noteData) toggleEditMode(noteCard, true, targetBtn, noteData);
                } else showModal('è­¦å‘Š', 'è«‹å…ˆå®Œæˆç·¨è¼¯ã€‚');
            });
            return noteCard;
        };

        const cleanupEditUI = (card) => loadNotes();

        const toggleEditMode = (card, enable, originalEditButton, noteData) => {
            const id = Number(card.dataset.noteId);
            const titleDisplay = card.querySelector('[data-field="title"]');
            const contentDisplay = card.querySelector('[data-field="content"]');
            const actionsDiv = card.querySelector('.actions');
            const deleteButton = card.querySelector('[data-action="delete"]');

            if (!titleDisplay || !contentDisplay || !actionsDiv || !deleteButton) { loadNotes(); return; }

            const originalTitle = noteData.title.trim();
            const originalContent = noteData.content.trim();
            const originalTags = noteData.tags ? noteData.tags.join(', ') : '';
            let currentEditImages = noteData.images || [];
            let currentEditVideos = noteData.videos || [];

            if (enable) {
                if (!originalEditButton) { loadNotes(); return; }
                isEditing = true;
                card.classList.add('border-purple-600', 'ring-4', 'ring-purple-200');
                card.classList.remove('border-indigo-500', 'hover:shadow-xl');
                originalEditButton.classList.add('hidden');
                const existingImagesDiv = card.querySelector('.note-image-display');
                if (existingImagesDiv) existingImagesDiv.classList.add('hidden');
                const existingVideosDiv = card.querySelector('.note-video-display');
                if (existingVideosDiv) existingVideosDiv.classList.add('hidden');

                const titleInput = document.createElement('input');
                titleInput.value = originalTitle;
                titleInput.className = 'w-full h-10 text-xl font-bold border-2 border-purple-400 rounded-lg p-2 mb-2 focus:outline-none focus:ring-2 focus:ring-purple-600 editable-field';

                const tagsInput = document.createElement('input');
                tagsInput.type = 'text';
                tagsInput.value = originalTags;
                tagsInput.placeholder = 'ç·¨è¼¯æ¨™ç±¤ (ç”¨é€—è™Ÿåˆ†éš”)...';
                tagsInput.className = 'w-full text-sm border-2 border-purple-400 rounded-lg p-2 mb-2 focus:outline-none focus:ring-2 focus:ring-purple-600 editable-field';

                const contentTextarea = document.createElement('textarea');
                contentTextarea.value = originalContent;
                contentTextarea.className = 'w-full text-gray-600 border-2 border-purple-400 rounded-lg p-2 mb-3 resize-y h-32 focus:outline-none focus:ring-2 focus:ring-purple-600 editable-field';

                titleDisplay.before(titleInput); titleDisplay.remove();

                // Remove existing tags display in edit mode to avoid clutter, or just keep it. 
                // Better to replace or insert input. Let's insert input after title.
                const tagsDisplay = card.querySelector('.flex.flex-wrap.gap-1');
                if (tagsDisplay) tagsDisplay.style.display = 'none';

                titleInput.after(tagsInput);

                contentDisplay.before(contentTextarea); contentDisplay.remove();

                const imageEditContainer = document.createElement('div');
                imageEditContainer.className = 'mt-4 border-t pt-4 space-y-2 edit-image-container editable-field';
                const label = document.createElement('label');
                label.className = 'block mb-2 text-sm font-medium text-gray-600';
                label.textContent = 'ç®¡ç†åœ–ç‰‡';
                const editImageInput = document.createElement('input');
                editImageInput.type = 'file'; editImageInput.accept = 'image/*'; editImageInput.multiple = true;
                editImageInput.className = 'w-full p-2 border border-gray-300 rounded-lg text-sm';
                const editPreviewGrid = document.createElement('div');
                editPreviewGrid.className = 'image-preview-grid mt-2';

                const renderEditPreview = () => {
                    editPreviewGrid.innerHTML = '';
                    if (currentEditImages.length === 0) return;
                    currentEditImages.forEach((img, idx) => {
                        const wrapper = document.createElement('div');
                        wrapper.className = 'image-thumbnail';
                        wrapper.innerHTML = `<img src="${img}">`;
                        const removeBtn = document.createElement('div');
                        removeBtn.className = 'remove-img-btn'; removeBtn.innerHTML = 'âœ•';
                        removeBtn.onclick = () => { currentEditImages.splice(idx, 1); renderEditPreview(); };
                        wrapper.appendChild(removeBtn); editPreviewGrid.appendChild(wrapper);
                    });
                };
                renderEditPreview();
                imageEditContainer.append(label, editImageInput, editPreviewGrid);

                // Video Management in Edit Mode
                const videoEditContainer = document.createElement('div');
                videoEditContainer.className = 'mt-4 border-t pt-4 space-y-2 edit-video-container editable-field';
                const vidLabel = document.createElement('label');
                vidLabel.className = 'block mb-2 text-sm font-medium text-gray-600';
                vidLabel.textContent = 'ç®¡ç†å½±ç‰‡';
                const editVideoInput = document.createElement('input');
                editVideoInput.type = 'file'; editVideoInput.accept = 'video/*'; editVideoInput.multiple = true;
                editVideoInput.className = 'w-full p-2 border border-gray-300 rounded-lg text-sm';
                const editVideoPreviewGrid = document.createElement('div');
                editVideoPreviewGrid.className = 'image-preview-grid mt-2';

                const renderEditVideoPreview = () => {
                    editVideoPreviewGrid.innerHTML = '';
                    if (currentEditVideos.length === 0) return;
                    currentEditVideos.forEach((vid, idx) => {
                        const wrapper = document.createElement('div');
                        wrapper.className = 'image-thumbnail relative';
                        wrapper.innerHTML = `<video src="${vid}" controls class="w-full h-full object-cover"></video>`;
                        const removeBtn = document.createElement('div');
                        removeBtn.className = 'remove-img-btn'; removeBtn.innerHTML = 'âœ•';
                        removeBtn.onclick = () => { currentEditVideos.splice(idx, 1); renderEditVideoPreview(); };
                        wrapper.appendChild(removeBtn); editVideoPreviewGrid.appendChild(wrapper);
                    });
                };
                renderEditVideoPreview();
                videoEditContainer.append(vidLabel, editVideoInput, editVideoPreviewGrid);

                card.insertBefore(imageEditContainer, card.querySelector('.text-xs'));
                card.insertBefore(videoEditContainer, card.querySelector('.text-xs'));

                // Insert tags input AFTER video container
                const tagsLabel = document.createElement('label');
                tagsLabel.className = 'block mb-2 text-sm font-medium text-gray-600 mt-4';
                tagsLabel.textContent = 'ç·¨è¼¯æ¨™ç±¤';
                card.insertBefore(tagsLabel, card.querySelector('.text-xs'));
                card.insertBefore(tagsInput, card.querySelector('.text-xs'));

                editImageInput.addEventListener('change', async (e) => {
                    const files = Array.from(e.target.files);
                    for (const file of files) {
                        if (file && file.type.startsWith('image/')) {
                            currentEditImages.push(await fileToDataURL(file));
                        }
                    }
                    editImageInput.value = ''; renderEditPreview();
                });

                editVideoInput.addEventListener('change', async (e) => {
                    const files = Array.from(e.target.files);
                    for (const file of files) {
                        if (file && file.type.startsWith('video/')) {
                            currentEditVideos.push(await fileToDataURL(file));
                        }
                    }
                    editVideoInput.value = ''; renderEditVideoPreview();
                });

                const saveButton = document.createElement('button');
                saveButton.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clip-rule="evenodd" /></svg>`;
                saveButton.className = 'save-btn p-2 rounded-full bg-green-500 text-white hover:bg-green-600 transition duration-150 temp-action-btn';
                const cancelButton = document.createElement('button');
                cancelButton.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z" clip-rule="evenodd" /></svg>`;
                cancelButton.className = 'cancel-btn p-2 rounded-full bg-gray-300 text-gray-700 hover:bg-gray-400 transition duration-150 temp-action-btn';
                actionsDiv.insertBefore(saveButton, deleteButton); actionsDiv.insertBefore(cancelButton, deleteButton);

                saveButton.addEventListener('click', () => {
                    const newTitle = titleInput.value.trim();
                    const newContent = contentTextarea.value.trim();
                    const newTagsStr = tagsInput.value.trim();
                    const newTags = newTagsStr ? newTagsStr.split(/[,ï¼Œ]/).map(t => t.trim()).filter(t => t.length > 0) : [];

                    if (!newTitle || !newContent) { showModal('è­¦å‘Š', 'ä¸èƒ½ç‚ºç©ºã€‚'); return; }
                    isEditing = false; updateNote(id, newTitle, newContent, currentEditImages, currentEditVideos, newTags);
                });
                cancelButton.addEventListener('click', () => {
                    const hasChanged = titleInput.value.trim() !== originalTitle || contentTextarea.value.trim() !== originalContent || tagsInput.value.trim() !== originalTags || JSON.stringify(currentEditImages) !== JSON.stringify(noteData.images || []) || JSON.stringify(currentEditVideos) !== JSON.stringify(noteData.videos || []);
                    if (hasChanged) showConfirmModal('æ”¾æ£„è®Šæ›´', 'ç¢ºå®šæ”¾æ£„ï¼Ÿ', () => { isEditing = false; cleanupEditUI(card); }, 'æ”¾æ£„');
                    else { isEditing = false; cleanupEditUI(card); }
                });
                titleInput.focus();
            }
        };

        const loadNotes = async () => {
            const notes = await getNotes();
            if (noteCountStatus) noteCountStatus.textContent = `ç•¶å‰ç­†è¨˜æ•¸é‡: ${notes.length} æ¢ã€‚`;
            const scrollPosition = window.scrollY;
            const notesContainer = document.getElementById('note-list');
            if (!notesContainer) return;

            // Gather all unique tags for filter
            const allTags = new Set();
            notes.forEach(note => {
                if (note.tags && Array.isArray(note.tags)) {
                    note.tags.forEach(tag => allTags.add(tag));
                }
            });

            // Update filter dropdown options
            if (tagFilterSelect) {
                const currentFilter = tagFilterSelect.value;
                // Keep the "All Tags" option
                tagFilterSelect.innerHTML = '<option value="">æ‰€æœ‰æ¨™ç±¤</option>';
                // Add tag options
                Array.from(allTags).sort().forEach(tag => {
                    const option = document.createElement('option');
                    option.value = tag;
                    option.textContent = tag;
                    tagFilterSelect.appendChild(option);
                });
                // Restore selection if still valid
                if (allTags.has(currentFilter)) {
                    tagFilterSelect.value = currentFilter;
                }
            }

            const sortBy = sortSelect ? sortSelect.value : 'updated_desc';
            const tagFilter = tagFilterSelect ? tagFilterSelect.value : '';

            // Filter notes
            let displayedNotes = notes;
            if (tagFilter) {
                displayedNotes = notes.filter(note => note.tags && note.tags.includes(tagFilter));
            }

            displayedNotes.sort((a, b) => {
                let timeA, timeB;
                if (sortBy.startsWith('created')) {
                    timeA = a.created_at || a.timestamp || 0;
                    timeB = b.created_at || b.timestamp || 0;
                } else {
                    timeA = a.updated_at || a.created_at || a.timestamp || 0;
                    timeB = b.updated_at || b.created_at || b.timestamp || 0;
                }
                return sortBy.endsWith('asc') ? timeA - timeB : timeB - timeA;
            });

            notesContainer.innerHTML = '';
            if (displayedNotes.length === 0) {
                if (tagFilter) {
                    notesContainer.innerHTML = '<p class="text-gray-500 text-center p-4">æ‰¾ä¸åˆ°ç¬¦åˆæ¨™ç±¤çš„ç­†è¨˜ã€‚</p>';
                } else {
                    notesContainer.innerHTML = '<p class="text-gray-500 text-center p-4">ç›®å‰æ²’æœ‰ä»»ä½•ç­†è¨˜ã€‚é»æ“Šã€Œæ–°å¢è¨˜äº‹ã€æˆ–ã€ŒåŒ¯å…¥ã€ä¾†é–‹å§‹å§ï¼</p>';
                }
                hideNoteForm();
                return;
            }

            displayedNotes.forEach((note) => {
                const createdAt = note.created_at || note.timestamp;
                const updatedAt = note.updated_at || note.timestamp;
                const images = note.images || (note.image ? [note.image] : []);
                const tags = note.tags || [];
                const videos = note.videos || [];
                notesContainer.appendChild(createNoteElement({
                    id: note.id, title: note.title, content: note.content, createdAt: createdAt, updatedAt: updatedAt, images: images, videos: videos, tags: tags
                }));
            });

            isEditing = false;
            requestAnimationFrame(() => { window.scrollTo(0, scrollPosition); });
        };

        const updateStorageStatusUI = () => {
            if (isFileSystemMode) {
                if (storageTypeInfo) {
                    storageTypeInfo.textContent = "ç›®å‰å„²å­˜ä½ç½®ï¼šæœ¬æ©Ÿè³‡æ–™å¤¾ (File System)";
                    storageTypeInfo.className = "text-sm text-green-700 mt-2 p-2 bg-green-100 inline-block rounded-full shadow-inner font-bold";
                }
                if (setFolderBtn) {
                    setFolderBtn.textContent = "åˆ‡æ›å›ç€è¦½å™¨å„²å­˜";
                    setFolderBtn.classList.replace('bg-blue-600', 'bg-gray-500');
                }
            } else {
                if (storageTypeInfo) {
                    storageTypeInfo.textContent = "ç›®å‰å„²å­˜ä½ç½®ï¼šç€è¦½å™¨ (IndexedDB)";
                    storageTypeInfo.className = "text-sm text-gray-500 mt-2 p-2 bg-white inline-block rounded-full shadow-inner";
                }
                if (setFolderBtn) {
                    setFolderBtn.textContent = "è¨­å®šå„²å­˜è³‡æ–™å¤¾";
                }
            }
        };

        // --- UI æ›´æ–°é‚è¼¯ ---
        const toggleMobileMenu = () => {
            const menu = document.getElementById('toolbar-menu');
            if (menu.classList.contains('hidden')) {
                menu.classList.remove('hidden');
                menu.classList.add('flex'); // ç¢ºä¿ç§»é™¤ hidden å¾Œæœ‰ flex å±¬æ€§
            } else {
                menu.classList.add('hidden');
                menu.classList.remove('flex'); // éš±è—æ™‚ç§»é™¤ flexï¼Œé¿å…å¹²æ“¾
            }
        };

        // --- Event Listeners ---
        document.addEventListener('DOMContentLoaded', () => {
            noteFormContainer = document.getElementById('note-form-container');
            toggleFormBtn = document.getElementById('toggle-form-btn');
            closeFormBtn = document.getElementById('close-form-btn');
            sortSelect = document.getElementById('sort-select');
            tagFilterSelect = document.getElementById('tag-filter'); // New
            noteCountStatus = document.getElementById('note-count-status');
            storageTypeInfo = document.getElementById('storage-type-info');
            storageSelect = document.getElementById('storage-selector');
            reconnectBtn = document.getElementById('reconnect-btn');
            setFolderBtn = document.getElementById('set-folder-btn');

            // æ¼¢å ¡æŒ‰éˆ•äº‹ä»¶ - Added safety check
            const mobileMenuBtn = document.getElementById('mobile-menu-btn');
            if (mobileMenuBtn) {
                mobileMenuBtn.addEventListener('click', toggleMobileMenu);
            }

            if (toggleFormBtn) toggleFormBtn.addEventListener('click', toggleNoteForm);
            if (closeFormBtn) closeFormBtn.addEventListener('click', hideNoteForm);
            if (sortSelect) sortSelect.addEventListener('change', loadNotes);
            if (tagFilterSelect) tagFilterSelect.addEventListener('change', loadNotes); // New
            if (storageSelect) storageSelect.addEventListener('change', handleStorageChange);

            if (reconnectBtn) reconnectBtn.addEventListener('click', reconnectLocalFolder);

            // éš±è—èˆŠçš„æŒ‰éˆ• (åŠŸèƒ½å·²è½‰ç§»)
            if (setFolderBtn) setFolderBtn.classList.add('hidden');

            const videoInput = document.getElementById('video-input');
            if (videoInput) {
                videoInput.addEventListener('change', async (e) => {
                    const files = Array.from(e.target.files);
                    for (const file of files) {
                        if (file && file.type.startsWith('video/')) {
                            currentNewNoteVideos.push(await fileToDataURL(file));
                        }
                    }
                    videoInput.value = '';
                    renderNewNoteVideosPreview();
                });
            }

            // åŒ¯å‡ºæŒ‰éˆ• (çµ±ä¸€æ ¼å¼)
            const exportBtn = document.getElementById('export-btn');
            if (exportBtn) {
                exportBtn.onclick = async () => {
                    const filenameBase = getBackupFilename();
                    const zip = new JSZip();
                    // ç„¡è«–ä½•ç¨®æ¨¡å¼ï¼Œæˆ‘å€‘éƒ½çµ±ä¸€å–å¾—è³‡æ–™ (å« Base64)
                    const notes = await getNotes();

                    if (notes.length === 0) { showModal('è­¦å‘Š', 'ç„¡è³‡æ–™å¯åŒ¯å‡º'); return; }

                    const notesExport = [];
                    notes.forEach((note, noteIndex) => {
                        const exportNote = {
                            id: note.id,
                            title: note.title, content: note.content,
                            created_at: note.created_at || note.timestamp,
                            updated_at: note.updated_at || note.timestamp,
                            timestamp: note.timestamp,
                            image_files: [],
                            video_files: [],
                            tags: note.tags || [] // Export tags
                        };

                        let imagesToExport = note.images || (note.image ? [note.image] : []);
                        let videosToExport = note.videos || [];

                        // ç”¨ ID ç•¶ä½œè³‡æ–™å¤¾åç¨± (FS/IDB ä¸€è‡´)
                        const folderId = isFileSystemMode ? note.id : note.id;

                        imagesToExport.forEach((imgBase64, index) => {
                            if (!imgBase64) return;
                            const mimeTypeMatch = imgBase64.match(/data:([^;]+);base64,/);
                            const ext = (mimeTypeMatch ? mimeTypeMatch[1] : 'image/png').split('/')[1] || 'png';

                            // è‹¥åŸæœ¬æœ‰è¨˜éŒ„æª”åå‰‡æ²¿ç”¨ï¼Œå¦å‰‡ç”Ÿæˆæ–°æª”å
                            const filename = (note.image_files && note.image_files[index]) ? note.image_files[index] : `image_${index}.${ext}`;

                            try {
                                zip.file(`images/${folderId}/${filename}`, dataURLToBlob(imgBase64));
                                exportNote.image_files.push(filename);
                            } catch (e) { console.error(e); }
                        });

                        videosToExport.forEach((vidBase64, index) => {
                            if (!vidBase64) return;
                            const mimeTypeMatch = vidBase64.match(/data:([^;]+);base64,/);
                            const mime = mimeTypeMatch ? mimeTypeMatch[1] : 'video/mp4';
                            let ext = mime.split('/')[1] || 'mp4';
                            if (ext === 'quicktime') ext = 'mov';

                            const filename = (note.video_files && note.video_files[index]) ? note.video_files[index] : `video_${index}.${ext}`;

                            try {
                                zip.file(`videos/${folderId}/${filename}`, dataURLToBlob(vidBase64));
                                exportNote.video_files.push(filename);
                            } catch (e) { console.error(e); }
                        });

                        notesExport.push(exportNote);
                    });

                    zip.file("notes.json", JSON.stringify(notesExport, null, 2));
                    zip.generateAsync({ type: "blob" }).then(content => {
                        const a = document.createElement('a');
                        a.href = URL.createObjectURL(content);
                        a.download = filenameBase;
                        a.click();
                    });
                };
            }

            // åŒ¯å…¥æŒ‰éˆ• (çµ±ä¸€æ ¼å¼)
            const importBtn = document.getElementById('import-btn');
            if (importBtn) {
                importBtn.onclick = () => {
                    const input = document.createElement('input');
                    input.type = 'file'; input.accept = '.zip'; input.style.display = 'none';
                    input.onchange = async (e) => {
                        if (e.target.files[0]) {
                            const file = e.target.files[0];
                            if (isFileSystemMode) await importFromZipToFS(file);
                            else await importFromZipToIDB(file);
                        }
                    };
                    document.body.appendChild(input); input.click(); document.body.removeChild(input);
                };
            }

            // IDB åŒ¯å…¥é‚è¼¯
            const importFromZipToIDB = async (zipFile) => {
                const zip = new JSZip();
                try {
                    const content = await zip.loadAsync(zipFile);
                    const notesFile = content.file('notes.json');
                    if (!notesFile) throw new Error("æ‰¾ä¸åˆ° notes.json");
                    const notes = JSON.parse(await notesFile.async('text'));

                    const preparedNotes = [];
                    for (const note of notes) {
                        let importedImages = [];
                        if (note.image_files && Array.isArray(note.image_files)) {
                            for (const filename of note.image_files) {
                                const path = `images/${note.id}/${filename}`;
                                const imgFile = content.file(path);
                                if (imgFile) {
                                    const base64 = await imgFile.async('base64');
                                    const mime = getMimeTypeFromFilename(filename);
                                    importedImages.push(`data:${mime};base64,${base64}`);
                                }
                            }
                        }

                        let importedVideos = [];
                        if (note.video_files && Array.isArray(note.video_files)) {
                            for (const filename of note.video_files) {
                                const path = `videos/${note.id}/${filename}`;
                                const vidFile = content.file(path);
                                if (vidFile) {
                                    const base64 = await vidFile.async('base64');
                                    const mime = getMimeTypeFromFilename(filename);
                                    importedVideos.push(`data:${mime};base64,${base64}`);
                                }
                            }
                        }
                        // ç›¸å®¹èˆŠç‰ˆå–®å±¤çµæ§‹
                        if (importedImages.length === 0 && note.image_files) {
                        }

                        const newNote = {
                            ...note,
                            images: importedImages,
                            videos: importedVideos,
                            created_at: note.created_at || Date.now(),
                            updated_at: note.updated_at || Date.now(),
                            timestamp: note.timestamp || Date.now()
                        };
                        delete newNote.id;
                        preparedNotes.push(newNote);
                    }

                    const db = await openNoteDB();
                    const tx = db.transaction([STORE_NAME], 'readwrite');
                    const store = tx.objectStore(STORE_NAME);

                    await new Promise((resolve, reject) => {
                        const req = store.clear();
                        req.onsuccess = resolve;
                        req.onerror = reject;
                    });

                    for (const n of preparedNotes) {
                        store.add(n);
                    }

                    await new Promise((resolve, reject) => {
                        tx.oncomplete = resolve;
                        tx.onerror = reject;
                    });

                    showModal('æˆåŠŸ', 'åŒ¯å…¥å®Œæˆï¼');
                    loadNotes();
                } catch (e) { showModal('éŒ¯èª¤', 'åŒ¯å…¥å¤±æ•—: ' + e.message); }
            };

            // ç¶å®šæ¨¡æ…‹è¦–çª—ä¸­çš„ç®¡ç†åŠŸèƒ½
            const manageAddBtn = document.getElementById('manage-add-btn');
            if (manageAddBtn) {
                manageAddBtn.onclick = async () => {
                    await setLocalFolder();
                    // ä¿®æ­£ï¼šé€™è£¡ä¸å†å‘¼å« closeManageModal()ï¼Œå› ç‚º setLocalFolder æˆåŠŸæ™‚æœƒè‡ªå‹•å‘¼å«ï¼Œ
                    // è‹¥å¤±æ•—æˆ–å–æ¶ˆå‰‡ä¸æ‡‰é—œé–‰è¦–çª—ã€‚
                };
            }

            const manageCloseBtn = document.getElementById('manage-close-btn');
            if (manageCloseBtn) manageCloseBtn.onclick = closeManageModal;

            const modalManageCloseX = document.getElementById('modal-manage-close-x');
            if (modalManageCloseX) modalManageCloseX.onclick = closeManageModal;

            // åˆå§‹åŒ–
            initStorage();

            const form = document.getElementById('note-form');
            if (form) {
                form.addEventListener('submit', (e) => { e.preventDefault(); createNote(document.getElementById('note-title').value.trim(), document.getElementById('note-content').value.trim()); });
            }

            const imageInput = document.getElementById('image-input');
            if (imageInput) {
                imageInput.multiple = true;
                imageInput.addEventListener('change', async (e) => {
                    const files = Array.from(e.target.files);
                    for (const file of files) {
                        if (file && file.type.startsWith('image/')) currentNewNoteImages.push(await fileToDataURL(file));
                    }
                    imageInput.value = ''; renderNewNoteImagesPreview();
                });
            }
            const removeImgBtn = document.getElementById('remove-image-btn');
            if (removeImgBtn) removeImgBtn.style.display = 'none';

            // Modal buttons event listeners moved inside DOMContentLoaded with safety checks
            const modalOkBtn = document.getElementById('modal-ok-btn');
            if (modalOkBtn) modalOkBtn.addEventListener('click', () => document.getElementById('custom-modal').classList.add('hidden'));

            const modalCancelBtn = document.getElementById('modal-cancel-btn');
            if (modalCancelBtn) modalCancelBtn.addEventListener('click', () => document.getElementById('custom-modal').classList.add('hidden'));
        });

        const showModal = (title, message) => {
            const modalTitle = document.getElementById('modal-title');
            if (modalTitle) modalTitle.textContent = title;
            const modalMessage = document.getElementById('modal-message');
            if (modalMessage) modalMessage.textContent = message;

            const confirmBtn = document.getElementById('modal-confirm-btn');
            if (confirmBtn) confirmBtn.classList.add('hidden');
            const okBtn = document.getElementById('modal-ok-btn');
            if (okBtn) okBtn.classList.remove('hidden');
            const cancelBtn = document.getElementById('modal-cancel-btn');
            if (cancelBtn) cancelBtn.classList.add('hidden');

            const customModal = document.getElementById('custom-modal');
            if (customModal) customModal.classList.remove('hidden');
        };
        const showConfirmModal = (title, message, onConfirm, confirmText = 'ç¢ºèªåˆªé™¤') => {
            const modalTitle = document.getElementById('modal-title');
            if (modalTitle) modalTitle.textContent = title;
            const modalMessage = document.getElementById('modal-message');
            if (modalMessage) modalMessage.textContent = message;

            const okBtn = document.getElementById('modal-ok-btn');
            if (okBtn) okBtn.classList.add('hidden');

            const confirmBtn = document.getElementById('modal-confirm-btn');
            if (confirmBtn) {
                confirmBtn.textContent = confirmText;
                confirmBtn.classList.remove('hidden');
                confirmBtn.onclick = () => { onConfirm(); document.getElementById('custom-modal').classList.add('hidden'); };
            }

            const cancelBtn = document.getElementById('modal-cancel-btn');
            if (cancelBtn) cancelBtn.classList.remove('hidden');

            const customModal = document.getElementById('custom-modal');
            if (customModal) customModal.classList.remove('hidden');
        };
    </script>
</body>

</html>